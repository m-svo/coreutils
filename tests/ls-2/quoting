#!/usr/bin/perl -w
require 5.003;
use strict;

my $program_name;
($program_name = $0) =~ s|.*/||;

# INPUTs
# ['contents']               contents only (file name is derived from test name)
# [{filename => 'contents'}] filename and contents
# [{filename => undef}]      filename only -- $(srcdir)/filename must exist
#                            (FIXME: note to self: get $srcdir from ENV)
# The file names from the inputs are concatenated in order on the command line
# FIXME: If there is more than one input file, the you can't specify REDIRECT.
# PIPE is still ok.
#
# OUTPUTs (always hash refs)
# {OUT => "data"}    put data in a temp file and compare it to stdout from cmd
# {OUT => ["filename"]} compare contents of existing filename to stdout from cmd
# Ditto for `ERR', but compare with stderr
# {EXIT => N} expect exit status of cmd to be N
#
# The OUT-keyed hash ref is the only one that's required.
# If the ERR-keyed one is omitted, then expect stderr to be empty.
# If the EXIT-keyed one is omitted, then expect exit status to be zero.

my @Tests =
    (
     # test-name options input expected-output
     #
     ['q-',        [{"q\a" => ''}], {OUT => "q\a\n"}],
     ['q-N', '-N', [{"q\a" => ''}], {OUT => "q\a\n"}],
     ['q-q', '-q', [{"q\a" => ''}], {OUT => "q?\n"}],
     ['q-Q', '-Q', [{"q\a" => ''}], {OUT => "\"q\\a\"\n"}],

     ['q-qs-lit', '--quoting=literal', [{"q\a" => ''}], {OUT => "q\a\n"}],
     ['q-qs-sh', '--quoting=shell',    [{"q\a" => ''}], {OUT => "q\a\n"}],
     ['q-qs-sh-a', '--quoting=shell-always', [{"q\a"=>''}], {OUT => "'q\a'\n"}],
     ['q-qs-c', '--quoting=c',         [{"q\a" => ''}], {OUT => "\"q\\a\"\n"}],
     ['q-qs-esc', '--quoting=escape',  [{"q\a" => ''}], {OUT => "q\\a\n"}],
    );

my $save_temps = 0;
my $verbose = 0;

my $prog = $ENV{LS} || 'ls';
my $fail = run_tests ($program_name, $prog, \@Tests, $save_temps, $verbose);
exit $fail;
