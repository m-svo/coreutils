# -*- sh -*-
# Source this file at the beginning of a test that works
# only when run as root or as non-root.

case "$PRIV_CHECK_ARG" in
  require-root) who='as root';;
  require-non-root) who='by an unprivileged user';;
  *) echo "Usage: PRIV_CHECK_ARG={require-root|require-non-root} . priv-check"\
     1>&2; exit 1;;
esac

priv_check_temp=priv-check.$$
touch $priv_check_temp || framework_failure=1
chmod a-w $priv_check_temp || framework_failure=1

# FIXME: use id -u, as below -- avoiding use of a temporary file
(echo foo >> $priv_check_temp) >/dev/null 2>&1
overwrite_status=$?
give_msg=no
case $PRIV_CHECK_ARG:$overwrite_status in
  require-root:0) ;;
  require-root:*) give_msg=yes ;;
  require-non-root:0) give_msg=yes ;;
  require-non-root:*) ;;
esac

test $give_msg = yes && {
  cat <<EOF
***************************
NOTICE:
$0: This test is being skipped, since it works only
when run $who.
***************************
EOF
  rm -f $priv_check_temp
  (exit 77); exit
}

test "$PRIV_CHECK_ARG" = require-root &&
{
  # When running as root, always ensure that we have a valid non-root username.
  : ${NON_ROOT_USERNAME=nobody}

  # Ensure that the supplied username is valid and with UID != 0.
  coreutils_non_root_uid=`setuidgid $NON_ROOT_USERNAME id -u`
  test $? = 0 || \
    {
      echo "$0: This command failed: \`setuidgid $NON_ROOT_USERNAME id -u'" 1>&2
      echo "$0: Skipping this test.  To enable it, set the envvar" 1>&2
      echo "$0: NON_ROOT_USERNAME to a non-root user name." 1>&2
      (exit 77); exit 77
    }
  test "$coreutils_non_root_uid" = 0 && \
    {
      echo "$0: The specified NON_ROOT_USERNAME ($NON_ROOT_USERNAME)" 1>&2
      echo "$0: is invalid because its UID is 0." 1>&2
      (exit 1); exit 1
    }
}

rm -f $priv_check_temp
