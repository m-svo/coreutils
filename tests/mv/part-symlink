#!/bin/sh
# make sure cp and mv can handle many combinations of local and
# other-partition regular/symlink'd files.

if test "$VERBOSE" = yes; then
  set -x
  mv --version
  cp --version
fi

pwd=`pwd`
tmp=part-sl.$$
trap 'status=$?; cd $pwd; rm -rf $tmp $other_partition_tmpdir && exit $status' 0
trap '(exit $?); exit' 1 2 13 15

pwd_tmp=$pwd/$tmp

. $srcdir/setup
. $srcdir/../envvar-check

if test -z "$other_partition_tmpdir"; then
  (exit 77); exit
fi

framework_failure=0
mkdir $tmp || framework_failure=1
cd $tmp || framework_failure=1

if test $framework_failure = 1; then
  echo 'failure in testing framework'
  exit 1
fi

fail=0

# Four cases:
# local regular file w/symlink on another partition
#   (loc_reg, rem_sl)
#   (rem_sl, loc_reg)
# local symlink to regular file on another partition
#   (loc_sl, rem_reg)
#   (rem_reg, loc_sl)

# Exercise those four cases for each of
# cp and mv, with lots of combinations of options.
# For now, just --rem and without.

actual=actual-$$
expected=expected-$$

exec 1> $actual

# FIXME: This should be bigger: like more than 8k
contents=XYZ

loc_reg=loc_reg
loc_sl=loc_sl
rem_reg=$other_partition_tmpdir/rem_reg
rem_sl=$other_partition_tmpdir/rem_sl

for copy in cp mv; do
  for args in \
      'loc_reg rem_sl' \
      'rem_sl loc_reg' \
      'loc_sl rem_reg' \
      'rem_reg loc_sl' \
      ; do
    for options in '' --rem '--rem -d' '--rem -b'; do
      case "$options" in *--rem*) test $copy = mv && continue;; esac
      rm -rf dir || fail=1
      rm -f $other_partition_tmpdir/rem_reg || fail=1
      rm -f $other_partition_tmpdir/rem_sl || fail=1
      mkdir dir || fail=1
      cd dir || fail=1
      case "$args" in *loc_reg*) reg_abs="`pwd`/$loc_reg" ;; esac
      case "$args" in *rem_reg*) reg_abs=$rem_reg ;; esac
      case "$args" in *loc_sl*) slink=$loc_sl ;; esac
      case "$args" in *rem_sl*) slink=$rem_sl ;; esac

      echo $contents > $reg_abs || fail=1
      ln -nsf $reg_abs $slink || fail=1
      actual_args=`echo $args|sed 's,^,$,;s/ / $/'`
      actual_args=`eval echo $actual_args`

      (
	(
	  # echo 1>&2 cp $options $args
	  $copy $options $actual_args 2>.err
	  copy_status=$?
	  echo $copy_status $copy $options $args

	  # Normalize the program name in the error output,
	  # remove any site-dependent part of other-partition file name,
	  # and put brackets around the output.
	  test -s .err && {
	    echo '[' | tr -d '\012'
	    sed 's/^[^:][^:]*\(..\):/\1:/;s,'$other_partition_tmpdir/,, .err
	    echo ']' | tr -d '\012'
	    }
	  # Strip off all but the file names.
	  # Remove any site-dependent part of each file name.
	  ls="`ls -lG --ignore=.err . \
	      | sed \
		  -e '/^total /d' \
		  -e s,$other_partition_tmpdir/,, \
		  -e s,$pwd_tmp/,, \
		  -e 's/^...............................................//'`"
	  ls2="`cd $other_partition_tmpdir && ls -lG --ignore=.err . \
	      | sed \
		  -e '/^total /d' \
		  -e s,$other_partition_tmpdir/,, \
		  -e s,$pwd_tmp/,, \
		  -e 's/^...............................................//'`"
	  echo "($ls) ($ls2)"

	  # If the command failed, then it must not have changed the files.
	  if test $copy_status != 0; then
	    for f in $actual_args; do
	      test -f $f ||
		{ echo "$copy FAILED but removed $f"; continue; }
	      case "`cat $f`" in
		"$contents") ;;
		*) echo "$copy FAILED but modified $f";;
	      esac
	    done
	  fi

	  if test $copy = cp; then
	    # Make sure the original is unchanged and that
	    # the destination is a copy.
	    for f in $actual_args; do
	      if test -f $f; then
		if test $copy_status != 0; then
		  test
		fi
		case "`cat $f`" in
		  "$contents") ;;
		  *) echo $copy FAILED;;
		esac
	      else
		echo symlink-loop
	      fi
	    done
	  fi
	) | tr '\012' ' '
	echo
      ) | sed 's/  *$//'
      cd ..
    done
    echo
  done
done

test $fail = 1 &&
  { (exit $?); exit; }

cat <<\EOF > $expected

EOF

# Uncomment this if you see a failure and want to try to diagnose it.
diff -u $expected $actual 1>&2

cmp $expected $actual

(exit $?); exit
